[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "CMC5105 - 수학교육통계분석: 회귀모형과 경시적 자료분석",
    "section": "",
    "text": "강의계획서\nCMC5105 - 수학교육통계분석: 회귀모형과 경시적 자료분석 (Statistical Analysis for Mathematics Educaiton: Regression Models and Longitudinal Data Analysis)\n2024-2학기 성균관대 교과교육학과(수학) 대학원\n월 6:00p–8:40p / 호암관 50415\n\n1. 강좌 개요와 목표\n\n본 과목에서는 수학교육학 및 사회과학 연구에 필요한 통계분석 방법론 중 가장 범용적 도구인 회귀모형(regression modeling) 및 경시적 자료 분석(longitudinal data analysis)의 원리를 소개하고 R로 실습한다.\n회귀모형은 두 변수 간의 관계성을 추정하는 모형을 일컫는다. 특히 두 변수가 선형관계를 갖는 경우 종속변수(\\(Y\\))에 대한 독립변수(\\(X\\))의 효과(\\(X\\)의 계수)의 추정이 사회과학 연구에 중요하다.\n경시적 자료(longitudinal data)는 한 단위에서 여러 관찰값을 갖는 자료를 뜻한다. 분야에 따라 종단면 자료, 패널자료(panel data) 또는 반복측정자료(repeatedly measured data)라고도 불린다. 예를 들어 한 집단을 장기간 추적관찰한 경우나 학급 단위로 평가가 실시된 경우에, 특정 요인이나 정책이 설명하는 변화량을 추정하고 싶을 때 본 방법론이 적절하다. 경시적 자료 분석기법들의 주요 관심사도 (회귀분석과 마찬가지로) 특정 독립변수의 효과를 편향되지 않게 추정하는 데 있다. 특히 경시자료는 관찰값들끼리 상관성이 존재하므로 평범한 회귀분석 기법을 적용할 경우 편향된 추정으로 이어질 수 있어 주의가 필요하다.\n실습코드 이해 및 프로젝트 진행을 위하여는 R 기본지식을 필요로 하므로, 수강희망자 중 R 선수경험이 없는 분께는 R 기초강좌 수강을 강력히 권장합니다 (예를들어 https://swb.skku.edu/rias/sub4.do).\n\n\n\n2. 교강사\n\n최영근 (성균관대 수학교육과 조교수)\ne-mail: ygchoi [at] skku [dot] edu\n홈페이지: https://sites.google.com/view/ygchoi\n연구실: 호암관 5층 51206호\noffice hour: 월 4:30pm-6pm\n\n\n\n3. 교재\n\n주교재: 강의노트를 자체제작 및 배부\n부교재\n\n회귀분석 기초이론 관련\n\n[1] 강근석, 유현조 (2016). R을 활용한 선형회귀분석. 교우사.\n[2] 한치록 (2024). 계량경제학 강의 (5판). 박영사.\n\n패널데이터 분석 관련\n\n[3] Frees (2004). Longitudinal and Panel Data: Analysis and Applications in the Social Sciences. Cambridge University Press.\n[4] 김양진 (2020). R과 SAS를 활용한 경시적 자료분석. 자유아카데미.\n\n[5] 한치록 (2024). 패널데이터강의 (4판). 박영사.\n\n\n교재들의 구매필요 여부는 추후공지\n\n\n\n4. 성적 및 평가\n\n출석 10%, 과제 45%, 프로젝트 45%\n과제: 이론/실습의 숙달 및 프로젝트 구상을 돕기 위한 연습문제들\n프로젝트: 본인이 관심있는 연구주제와 데이터를 골라서, 수업시간에 다루어진 기법들을 활용하여 간단한 자료탐색과 분석을 진행\n\n프로포절: 8주차 월, 5분 발표, 5분 질의응답\n본발표: 16주차 월, 25분 발표, 10분 질의응답\n보고서 제출기한: 16주차 금\n\n양적연구 논문의 형식을 갖출 것 (서론 / 연구방법 / 결과 / 해석)\n분량은 10매 이내 (기준: 표와 그림 포함, 참고문헌 제외)\n\n\n\n\n\n5. 강의 주제\n\n회귀분석\n\n시각화를 통한 탐색적 자료분석\n관측치가 하나일 때의 기본적 회귀분석모형\n\n단순선형회귀모형 (simple linear regression)\n다중선형회귀모형 (multiple linear regression)\n로지스틱 선형회귀모형 (logistic linear regression)\n일반화 선형모형 (generalized linear model)\n\n\n경시적 자료의 회귀분석\n\n시각화를 통한 탐색적 자료분석\n반응변수가 연속형인 경시자료에 대한 선형모형\n\n고정효과모형 (fixed effect model)\n임의효과모형 (random effect model)\n혼합효과모형 (mixed effect model)\n\n반응변수가 범주형인 경시자료에 대한 선형모형\n\n일반화 선형혼합모형 (generalized linear mixed effect model)\n일반화 추정방정식 (generalized estimating equation)",
    "crumbs": [
      "강의계획서"
    ]
  },
  {
    "objectID": "R-1-basics.html",
    "href": "R-1-basics.html",
    "title": "1  R - 기초 연산",
    "section": "",
    "text": "1.1 R 소개",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>R - 기초 연산</span>"
    ]
  },
  {
    "objectID": "R-1-basics.html#r-소개",
    "href": "R-1-basics.html#r-소개",
    "title": "1  R - 기초 연산",
    "section": "",
    "text": "통계적 계산에 특화된 컴퓨팅 언어\n장점\n\n무료, 오픈소스\n데이터 전처리 (특정 요소 검색과 필터링), 수학적 계산 및 그림그리기가 쉽고 빠름\n웬만한 작업에서 구글링으로 도움 받을 수 있음 (R 관련 온오프라인 커뮤니티가 활성화되어 있음, 학계 및 일부 산업계에서 활용중)\n\n단점\n\nvs. SPSS / Stat / SAS : 프로그래밍 지식 필요 (진입장벽 있음), 무보증 (오픈소스이므로)\nvs. Python : 프로그래밍적 체계가 다소 부족 (완벽한 자동화와 대형화에는 불리)\nR 설치(Windows 기준) : https://cran.r-project.org → ‘Download R for Windows’→ base → ‘Download R 4.X.X for Windows’ *** 설치 언어 선택시 영어 권장 (오류메시지 구글링 용이) ***\nRStudio 설치(Windows 기준) : https://www.rstudio.com → ‘Download’ → ‘Download RStudio Desktop’ → Windows 11/10/8/7\nGoogle Colab을 이용하여 클라우드 환경에서의 R 실습도 가능하다: https://colab.research.google.com/notebook#create=true&language=r으로 이동하여 노트북을 생성하면, 메뉴의 ’런타임 유형 변경’을 눌렀을 때 R 런타임이 추가된 것을 확인할 수 있다.\n\nRemark : R 혹은 기타 프로그래밍 언어에 빨리 익숙해지는 지름길은 모든 코드를 직접 쳐 보는 것. 복사 & 붙여넣기는 당분간 자제",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>R - 기초 연산</span>"
    ]
  },
  {
    "objectID": "R-1-basics.html#계산기로서의-r-명령-실행시키기",
    "href": "R-1-basics.html#계산기로서의-r-명령-실행시키기",
    "title": "1  R - 기초 연산",
    "section": "1.2 계산기로서의 R, 명령 실행시키기",
    "text": "1.2 계산기로서의 R, 명령 실행시키기\n\n콘솔창에 한줄한줄 입력해 보자. 무엇이 출력되는가?\n\n\n2 + 2\n\n[1] 4\n\n2 + 3*3\n\n[1] 11\n\n(2 + 3)*3\n\n[1] 15\n\n4^2\n\n[1] 16\n\n4^(1/2)\n\n[1] 2\n\n4^(0.5)\n\n[1] 2\n\nexp(-2)\n\n[1] 0.1353353\n\nsqrt(4)\n\n[1] 2\n\nsqrt(-1)            # 기본적으로 R은 실수만 가지고 논다.\n\nWarning in sqrt(-1): NaNs produced\n\n\n[1] NaN\n\nlog(1)          # log, exp 함수는 모두 밑이 자연상수 e.\n\n[1] 0\n\nlog(exp(1))\n\n[1] 1\n\n\n\n+(더하기), -(빼기), *(곱하기), /(나누기), ^(지수), exp, log, sqrt 등으로 다양한 계산을 할 수 있다. - 자주 쓰이는 수학 함수로는 abs(), exp(), log(), log10(), sin(), cos(), tan(), asin(), acos(), atan() 등이 있다. 물론 여러 개를 복합하여도 좋다. 예를 들자면,\n\n(굳이 칠 필요 없음)\n4^log(log(log(4219711))) / sqrt(54 / 218)\n\n괄호가 없을 경우 연산의 순서는 수학에서의 연산 순서와 같다고 생각하면 된다. 연산의 순서가 헷갈리면 괄호를 적극 활용하라.\n연산 순서에서의 우선순위 지정은 무조건 괄호 ()로 해야 한다. 수학 교과서에서 통용되는 다른 괄호기호는 R에서는 다른 용도로 사용된다. 가령, bracket(‘[’)은 인덱스 지정에 사용되며, brace(‘{’)는 코드 묶음을 위하여 사용된다.\n열린 괄호는 반드시 닫혀야 정상적인 계산이 가능\nR이 명령을 인식하는 단위는 엔터키(newline) 또는 세미콜론(;)이다.\n\n\na = 4 ; b = 3 ; a ; b ;\n\n[1] 4\n\n\n[1] 3\n\n\n\n콘솔 창이 활성화된 상태에서 키보드의 위쪽 방향키(↑)를 눌러 보면 이전에 실행한 명령들을 다시 불러올 수 있다.\n’#’은 코멘트 기능을 한다. # 뒤로 입력된 글자는 프로그램에서 인식하지 않는다.\n\n\na = 10 ; # b = 10 ; abcdefg ABCDEFG e.e.e.e.@(@(@(@(@(\n# a ; b ;\na ; b ;\n\n[1] 10\n\n\n[1] 3",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>R - 기초 연산</span>"
    ]
  },
  {
    "objectID": "R-1-basics.html#변수-지정",
    "href": "R-1-basics.html#변수-지정",
    "title": "1  R - 기초 연산",
    "section": "1.3 변수 지정",
    "text": "1.3 변수 지정\n\nR에서 등호(‘=’)는 ’같다’라는 뜻이 아니고 ’우변의 값을 좌변에 대입하라’라는 뜻의 대입 연산자이다.\n\n\na = 2 \na                   # 저장된 변수를 이렇게 볼 수 있다.\n\n[1] 2\n\nA = 4 \nA \n\n[1] 4\n\na                   # R에 저장되는 변수/함수들은 대소문자를 구분한다.\n\n[1] 2\n\nA + a \n\n[1] 6\n\nB = A + a \nB^a \n\n[1] 36\n\na = a + a               # 'a + a'를 계산해서 그 값을 기존의 a 자리에 대입하라.\na \n\n[1] 4\n\n\n\n변수명 지정 규칙\n\n영어 알파벳, 숫자, 언더바(‘_’), 마침표(‘.’)의 조합만 가능 eg) a, X, y_0_estimate, result.value_1\n첫 글자는 반드시 문자로. 2M, _result 등은 변수의 이름이 될 수 없다.\n프로그램에서 미리 지정한 변수/함수 이름은 사용할 수 없다. pi, log, exp… 등은 쓰지 말 것. PI, LOG, EXP.. 등은 대소문자 구분 규칙상 사용 가능하긴 하나 비권장.\n\n변수에 벡터를 입력해 보자. 다음은 모두 같은 벡터를 입력하는 방법이다.\n\n\na = c(1, 2, 3, 4) \nb = 1:4 \nc = (1:4) \nd = seq(1, 4, 1) \na \n\n[1] 1 2 3 4\n\nb \n\n[1] 1 2 3 4\n\nc \n\n[1] 1 2 3 4\n\nd \n\n[1] 1 2 3 4\n\n\n\n변수를 거치지 않고 콘솔에 c(1, 2, 3, 4)만 입력할 수도 있다.\n다양한 벡터 표현의 조합도 가능\n\n\ne = c( c(3, 6, 1, 1), a, seq(10, 1, -2), 6, 1 )\n\n\n만약 벡터 e의 7번째 성분만 따로 빼내고 싶다면?\n\n\ne[7]\n\n[1] 3\n\n\n\n물론 A = e[7] ; 로 e 벡터의 7번째 성분값만 다른 변수로 지정할 수도 있다.\n변수에 저장되는 다양한 형태의 자료(벡터, 행렬, 리스트, 데이터 프레임….)를 다루는 법은 세션 3에서 다룬다.\n변수에는 수 뿐만 아니라 문자열도 저장할 수 있다. 문자열을 저장할 땐 반드시 쌍따옴표 혹은 단따옴표를 붙인다는 것을 기억하자.\n\n\na = 'computer' ;\na\n\n[1] \"computer\"\n\nstr = c('stat', 'research', 'community') ;\nstr\n\n[1] \"stat\"      \"research\"  \"community\"",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>R - 기초 연산</span>"
    ]
  },
  {
    "objectID": "R-1-basics.html#여러-명령의-편집을-위한-도구-스크립트-r-studio",
    "href": "R-1-basics.html#여러-명령의-편집을-위한-도구-스크립트-r-studio",
    "title": "1  R - 기초 연산",
    "section": "1.4 여러 명령의 편집을 위한 도구 : 스크립트, R Studio",
    "text": "1.4 여러 명령의 편집을 위한 도구 : 스크립트, R Studio\n\n스크립트: 보통 여러 줄의 코드로 이루어진 텍스트 파일. 보통의 코드는 하나의 목표를 위해 여러 명령을 실행하므로, 이들을 한 파일로 관리한다.\nRStudio는 R 스크립트의 실행과 관리를 보조하는 통합 개발 환경 (integrated deverlopment environment)이다. RStudio를 이용하면 R을 사용하며 자주 겪는 일들 (여러 변수 다루기, 도움말 보기, 그림 확인 등)을 더 편하게 할 수 있고, 간단한 문법 교정 (괄호가 잘 열고 닫혔는지) 및 syntax highlight도 지원한다.\nRStudio에서 여러 줄의 코드 입력한 후 실행하기\n\nFile → New → R Script\n코드 여러 줄 입력\n블록 지정, 혹은 실행시키고 싶은 줄에 커서를 옮기고 마우스 오른쪽 버튼 → [줄 또는 선택영역 실행] (단축키 : Ctrl + Enter 혹은 Shift + Enter)\n\n다음을 스크립트에 입력하고 블록 지정을 이용하여 실행하여 보고 줄별 실행도 해 보라.\n작성한 스크립트의 저장은, 해당 스크립트 창이 활성화된 상태에서 메뉴의 [File] - [Save]을 이용하여 저장할 수 있다. ’****.R’의 형식으로 저장하면 된다.\n저장한 스크립트는 메뉴의 [File] - [Open]를 통하여 불러올 수 있다. RStudio가 없으면 R 혹은 메모장에서도 불러올 수 있다.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>R - 기초 연산</span>"
    ]
  },
  {
    "objectID": "R-1-basics.html#화면에-문자열-출력",
    "href": "R-1-basics.html#화면에-문자열-출력",
    "title": "1  R - 기초 연산",
    "section": "1.5 화면에 문자열 출력",
    "text": "1.5 화면에 문자열 출력\n\n다음을 콘솔에 입력하여 보자.\n\n\ncat('Hello!')\n\nHello!\n\n\n\nHello가 화면에 나타나고 바로 뒤에 &gt;가 나타난다. Hello 밑 줄에 &gt;가 뜨게 하고 싶으면?\n\n\ncat('Hello!') ;\n\nHello!\n\ncat('Hello!\\n') ;\n\nHello!\n\ncat('Hello!\\n\\n')\n\nHello!\n\ncat('He\\nllo!\\n')\n\nHe\nllo!\n\n\n\n‘’ 은 ‘한 줄을 띄우라’는 뜻의 문자열형 상수이다. ’한 탭만 옆으로 가라’을 뜻하는 캐릭터인’도 있다. 다음을 입력해 보자.\n\n\ncat('H\\tello!\\n') ;\n\nH   ello!\n\ncat('H\\te\\tl\\tl\\to!\\n') ;\n\nH   e   l   l   o!\n\n\n\n변수를 출력에 이용할 수도 있다. 다음을 차례대로 쳐 보자.\n\n\ni = 4 ; j = 3 ; string = 'i is' ;\ncat(i) \n\n4\n\ncat(i, j) \n\n4 3\n\ncat('i is', i) ;\n\ni is 4\n\n        # 문자열은 언제나 쌍따옴표('')를 붙여야 R이 문자열로 인식한다.\ncat(string, i) \n\ni is 4\n\n        # string에 'i is'가 이미 문자열로 저장되어 있으므로 호출할 때 쌍따옴표 불필요\n\n\nsprintf() 함수로 출력 포맷에 맞는 문자열을 만들어 출력시킬 수도 있다.\n\n\nstr = sprintf('i is %d, j is %d, string is %s\\n', i, j, string)\nstr\n\n[1] \"i is 4, j is 3, string is i is\\n\"\n\ncat(str)\n\ni is 4, j is 3, string is i is\n\n\n\nfor 구문은 다음 세션에서 다룰 예정이나, 아래를 미리 한번 해보라.\n\n\nfor (i in 1:10)\n{\n    cat(sprintf('Currint i is %d\\n', i)) \n}\n\nCurrint i is 1\nCurrint i is 2\nCurrint i is 3\nCurrint i is 4\nCurrint i is 5\nCurrint i is 6\nCurrint i is 7\nCurrint i is 8\nCurrint i is 9\nCurrint i is 10",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>R - 기초 연산</span>"
    ]
  },
  {
    "objectID": "R-1-basics.html#도움말",
    "href": "R-1-basics.html#도움말",
    "title": "1  R - 기초 연산",
    "section": "1.6 도움말",
    "text": "1.6 도움말\nR의 모든 기능 및 함수의 사용법을 외우고 있는 사람은 아마 없을 것이다. 다음과 같은 도움말들을 이용할 수 있다.\n\nHtml help : help.start() ;\nFunction help : help(function) ; or ?function ;\n\nhelp(solve)\n?solve\n\nExamples of functions : example(function)\n\nexample(solve)\n\n\n물론 구글링이나 생성AI도 좋은 가이드를 준다. 특히 RDocumentation.org의 문서들은 공식 매뉴얼이다.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>R - 기초 연산</span>"
    ]
  },
  {
    "objectID": "R-2-vec-mat.html",
    "href": "R-2-vec-mat.html",
    "title": "2  R - 행렬과 벡터",
    "section": "",
    "text": "2.1 벡터\n벡터는 동일한 자료형(숫자, 문자열 등)의 모음이다. 벡터는 R의 모든 연산의 근간이다. 여기서는 벡터의 생성법 및 특정 성분으로의 접근법을 소개한다.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>R - 행렬과 벡터</span>"
    ]
  },
  {
    "objectID": "R-2-vec-mat.html#벡터",
    "href": "R-2-vec-mat.html#벡터",
    "title": "2  R - 행렬과 벡터",
    "section": "",
    "text": "2.1.1 수치형(numeric) 벡터의 생성\n\nc(), (number):(number), seq(), rep() 등을 이용할 수 있다.\n\n\nc(1, 4, 3, 5) \n\n[1] 1 4 3 5\n\na = 1:4 \nb = 15 \nc( c(2, 4), a, b ) \n\n[1]  2  4  1  2  3  4 15\n\nseq(1, 11, 3) \n\n[1]  1  4  7 10\n\n# seq()는 from, to, length, by를 지정할 수도 있다. to나 length 중의 하나만 지정하면 수열이 결정# 되므로 둘 중의 하나만 택하는 걸 권한다.\nseq(from = 1, to = 11, by = 3) \n\n[1]  1  4  7 10\n\nseq(from = 1, length = 4, by = 3)\n\n[1]  1  4  7 10\n\nrep(1, 6)\n\n[1] 1 1 1 1 1 1\n\nrep(c(1, 2), 5)\n\n [1] 1 2 1 2 1 2 1 2 1 2\n\nrep(c(1, 2, 3), c(4, 3, 2))\n\n[1] 1 1 1 1 2 2 2 3 3\n\n\n\n벡터에 입력될 수 있는 성분은 수치(numeric)뿐만 아니라 logical(논리형), character(문자열)도 가능하다. 벡터의 자료형별로 적절한 연산들이 지원된다.\n\n\na = \"stat\"\nb = c(\"research\", \"community\")\npaste(a, b)                    # 두 문자열을 붙이기\n\n[1] \"stat research\"  \"stat community\"\n\nf = TRUE ; g = c(FALSE, TRUE) ;\nf | g                          # or 연산\n\n[1] TRUE TRUE\n\nf & g                         # and 연산\n\n[1] FALSE  TRUE\n\n\n\n한 벡터/행렬에는 같은 유형의 성분만 사용되는 것이 원칙. 단 NA, NULL은 예외. NA와 NULL은 실수형 벡터(행렬), 논리형 벡터(행렬).. 등 자료 구성원의 유형에 관계없이 성분이 될 수 있다.\n\n\na = c(1, 2, 3)\nb = c(1, 2, NA)\nc = c(1, 2, \"ch\")\na ; b ; c\n\n[1] 1 2 3\n\n\n[1]  1  2 NA\n\n\n[1] \"1\"  \"2\"  \"ch\"\n\n\n\n\n2.1.2 벡터 객체로의 접근법\n\n성분에 접근하려면 대괄호 []를 이용한다. 벡터 a에 대해 a[index number]를 입력하는 것이 보편적이다. index number에 아무 것도 입력하지 않으면 모든 성분을 불러온다.\n\n\na = c(1, 5, 8, 7) ;\na \n\n[1] 1 5 8 7\n\na[3]\n\n[1] 8\n\na[ ]\n\n[1] 1 5 8 7\n\nc(1, 5, 8, 7) [3] \n\n[1] 8\n\n\n\n한꺼번에 여러 index의 성분을 추출할 수도 있다. 단, index들을 벡터로 묶어서 알려줘야 한다.\n\n\nx = seq(from = 10, to = 100, by = 10)\nx\n\n [1]  10  20  30  40  50  60  70  80  90 100\n\nx[c(2, 4, 6, 8, 10)] \n\n[1]  20  40  60  80 100\n\ny = x[seq(2, 10, 2)] \ny\n\n[1]  20  40  60  80 100\n\n\n\n추출하지 않을 성분을 알려주어 나머지 성분을 추출할 수도 있다.\n\n\nx = seq(from = 10, length = 100, by = 10)\nx\n\n  [1]   10   20   30   40   50   60   70   80   90  100  110  120  130  140  150\n [16]  160  170  180  190  200  210  220  230  240  250  260  270  280  290  300\n [31]  310  320  330  340  350  360  370  380  390  400  410  420  430  440  450\n [46]  460  470  480  490  500  510  520  530  540  550  560  570  580  590  600\n [61]  610  620  630  640  650  660  670  680  690  700  710  720  730  740  750\n [76]  760  770  780  790  800  810  820  830  840  850  860  870  880  890  900\n [91]  910  920  930  940  950  960  970  980  990 1000\n\nx[-1]\n\n [1]   20   30   40   50   60   70   80   90  100  110  120  130  140  150  160\n[16]  170  180  190  200  210  220  230  240  250  260  270  280  290  300  310\n[31]  320  330  340  350  360  370  380  390  400  410  420  430  440  450  460\n[46]  470  480  490  500  510  520  530  540  550  560  570  580  590  600  610\n[61]  620  630  640  650  660  670  680  690  700  710  720  730  740  750  760\n[76]  770  780  790  800  810  820  830  840  850  860  870  880  890  900  910\n[91]  920  930  940  950  960  970  980  990 1000\n\nx[-c(1, 2)]\n\n [1]   30   40   50   60   70   80   90  100  110  120  130  140  150  160  170\n[16]  180  190  200  210  220  230  240  250  260  270  280  290  300  310  320\n[31]  330  340  350  360  370  380  390  400  410  420  430  440  450  460  470\n[46]  480  490  500  510  520  530  540  550  560  570  580  590  600  610  620\n[61]  630  640  650  660  670  680  690  700  710  720  730  740  750  760  770\n[76]  780  790  800  810  820  830  840  850  860  870  880  890  900  910  920\n[91]  930  940  950  960  970  980  990 1000\n\n\n\n그 외에도 벡터에 대한 정보를 알려주는 다양한 함수들이 있다.\n\n\nx = seq(from = 1, length = 100, by = 2) ;\n\nlength(x)               # x의 길이\n\n[1] 100\n\nhead(x)             # x의 최초 6개 성분만 열람\n\n[1]  1  3  5  7  9 11\n\nsummary(x)              # x의 성분들에 대한 기초통계 결과\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n    1.0    50.5   100.0   100.0   149.5   199.0 \n\nsum(x)              # x의 성분들의 합\n\n[1] 10000\n\nmean(x)             # x의 성분들의 평균\n\n[1] 100\n\nvar(x)              # x의 성분들의 표본분산(편차제곱을 n-1로 나눔)\n\n[1] 3366.667\n\n\n\nc(1, 5, 19, 2, 1, 2, 2, 8)에 대하여 min(x), max(x), order(x), factor(x), table(x)… 등도 각자 해 보길 바란다. factor(x)와 table(x)는 x가 연속형 실수가 아닌 이산형(문자열형, 혹은 1, 2, 3, ..등)으로 이루어진 자료일 경우에 유용하다.\n\n\n\n2.1.3 수치형 벡터의 연산\n\n기본적으로 R은 열벡터(column vector)에 매우 친화적이다. R에서 벡터는 열벡터로 인식된다. 벡터가 화면에 가로로 나열되는 건 경제성을 위해서이다. 스칼라값도 R 내부적으로는 길이 1짜리 벡터로 취급된다.\nR은 벡터 단위의 연산을 제공한다. 스칼라 곱은 당연히 되며, element-wise operation 또한 가능하다. element-wise operation은 행렬끼리의 연산에서도 지원된다. R의 좋은 기능 중 하나다.\n\n\na = pi/4\ntan(a)\n\n[1] 1\n\nb = c(pi/3, pi/4, pi/6) \nsin(b)              # element-wise operation\n\n[1] 0.8660254 0.7071068 0.5000000\n\nexp(c(-1, 0, 1)) \n\n[1] 0.3678794 1.0000000 2.7182818\n\nd = exp(c(-1, 0, 1)) \nb + d               # element-wise operation\n\n[1] 1.415077 1.785398 3.241881\n\nb - d               # element-wise operation\n\n[1]  0.6793181 -0.2146018 -2.1946831\n\nx = c(1, 2, 3) ; y = c(1, 2, 3) \nx - 1\n\n[1] 0 1 2\n\n2 * x \n\n[1] 2 4 6\n\nx * y               # element-wise operation\n\n[1] 1 4 9\n\nsum(x * y)              # inner product of x and y\n\n[1] 14\n\nx / y               # element-wise operation\n\n[1] 1 1 1\n\n\n\nx - 1은 왜 가능할까? 길이가 다른 두 벡터가 만나면 짧은 벡터가 알아서 복제된다. 다만, 길이들이 서로 약수/배수의 관계에 있어야 warning이 뜨지 않는다.\n\n\nx = c(1, 2, 3, 4, 5) \nx - c(1,2) ;                # warning. 실제로는 c(1, 2, 3, 4, 5) - c(1, 2, 1, 2, 1) 계산\n\nWarning in x - c(1, 2): longer object length is not a multiple of shorter\nobject length\n\n\n[1] 0 0 2 2 4\n\nx - 1               # 실제로는 c(1, 2, 3, 4, 5) - c(1, 1, 1, 1, 1) 계산\n\n[1] 0 1 2 3 4\n\n\n\n한편, 위에서 보았듯 *은 기본적으로 성분별 곱셈 연산자이며 이는 행렬에서도 똑같이 취급된다. 행렬의 곱셈은 연산자 %*%로 한다.\n크롤링 이후에는 문자열형 벡터를 자주 다루게 된다. R의 stringr 패키지를 이용하면 문자열형 벡터도 다양한 변환이 가능하다. 다음 링크의 53페이지부터 따라하면 된다: https://statkclee.github.io/yonsei/data/R_Web_Crawling.pdf",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>R - 행렬과 벡터</span>"
    ]
  },
  {
    "objectID": "R-2-vec-mat.html#행렬",
    "href": "R-2-vec-mat.html#행렬",
    "title": "2  R - 행렬과 벡터",
    "section": "2.2 행렬",
    "text": "2.2 행렬\n\n2.2.1 행렬의 생성\n\n일러두기: 아래 예시코드들에서는 쉬운 설명을 위하여 수치형 행렬만 다루고 있으나, 논리형/문자열형 행렬도 같은 코드로 생성/접근이 가능하다.\n기본적으로 행렬은 matrix()와 벡터로부터 만든다. 관습과 다르게 R은 행렬을 column-wise 채워나간다. R이 열벡터에 친화적이라는 점을 기억하자. row-wise 채워나가려면 byrow=TRUE 옵션을 붙여준다.\n\n\na = 1:6 \nb = matrix(a, nrow = 3, ncol = 2) \nb \n\n     [,1] [,2]\n[1,]    1    4\n[2,]    2    5\n[3,]    3    6\n\nmatrix(a, nrow =3, ncol = 2, byrow = TRUE) ;\n\n     [,1] [,2]\n[1,]    1    2\n[2,]    3    4\n[3,]    5    6\n\nmatrix(a, 3, 2, byrow = T) ;\n\n     [,1] [,2]\n[1,]    1    2\n[2,]    3    4\n[3,]    5    6\n\nmatrix(a, 3, byrow = T) ;\n\n     [,1] [,2]\n[1,]    1    2\n[2,]    3    4\n[3,]    5    6\n\n\n\nrbind(), cbind()는 길이가 같은 벡터들을 행별/열별로 엮어 행렬로 만들어 준다. diag()은 대각행렬을 만들 때 유용하다.\n\n\nx = 1:3 ; y = 4:6 ; A = matrix(7:12, nrow = 3)\nrbind(x, y)\n\n  [,1] [,2] [,3]\nx    1    2    3\ny    4    5    6\n\ncbind(x, y)\n\n     x y\n[1,] 1 4\n[2,] 2 5\n[3,] 3 6\n\ncbind(x, y, A)\n\n     x y     \n[1,] 1 4 7 10\n[2,] 2 5 8 11\n[3,] 3 6 9 12\n\ndiag(x)\n\n     [,1] [,2] [,3]\n[1,]    1    0    0\n[2,]    0    2    0\n[3,]    0    0    3\n\n\n\n\n2.2.2 행렬 객체로의 접근\n\n성분에 접근하는 방법은 벡터와 매우 유사하다. 다만 쉼표를 이용하여 A[row index, col index]의 형식을 취한다. 만약 index에 아무 것도 입력하지 않으면 모든 index를 불러온다. 쉼표(‘,’)는 반드시 써야 한다.\n\n\nA = matrix(1:12, nrow = 3, byrow = TRUE)\nA\n\n     [,1] [,2] [,3] [,4]\n[1,]    1    2    3    4\n[2,]    5    6    7    8\n[3,]    9   10   11   12\n\nA[ ]\n\n     [,1] [,2] [,3] [,4]\n[1,]    1    2    3    4\n[2,]    5    6    7    8\n[3,]    9   10   11   12\n\nA[ , ] \n\n     [,1] [,2] [,3] [,4]\n[1,]    1    2    3    4\n[2,]    5    6    7    8\n[3,]    9   10   11   12\n\nA[2, 3]\n\n[1] 7\n\nA[1, ]\n\n[1] 1 2 3 4\n\nA[c(1,2), ]\n\n     [,1] [,2] [,3] [,4]\n[1,]    1    2    3    4\n[2,]    5    6    7    8\n\nA[ , -1]\n\n     [,1] [,2] [,3]\n[1,]    2    3    4\n[2,]    6    7    8\n[3,]   10   11   12\n\n\n\n벡터의 정보를 파악하기 위해 썼던 함수들은 대부분 행렬에도 적용 가능하다. 벡터 예제와 비교하여, 새롭게 dim()만 추가하였다.\n아래 코드들과 더불어, min(x), max(x), order(x), factor(x), table(x).. 들도 여전히 유효한지 확인해 보라.\n\n\nA = matrix(1:60, nrow = 15, byrow = TRUE )\nA\n\n      [,1] [,2] [,3] [,4]\n [1,]    1    2    3    4\n [2,]    5    6    7    8\n [3,]    9   10   11   12\n [4,]   13   14   15   16\n [5,]   17   18   19   20\n [6,]   21   22   23   24\n [7,]   25   26   27   28\n [8,]   29   30   31   32\n [9,]   33   34   35   36\n[10,]   37   38   39   40\n[11,]   41   42   43   44\n[12,]   45   46   47   48\n[13,]   49   50   51   52\n[14,]   53   54   55   56\n[15,]   57   58   59   60\n\nhead(A)\n\n     [,1] [,2] [,3] [,4]\n[1,]    1    2    3    4\n[2,]    5    6    7    8\n[3,]    9   10   11   12\n[4,]   13   14   15   16\n[5,]   17   18   19   20\n[6,]   21   22   23   24\n\nlength(A)\n\n[1] 60\n\ndim(A)\n\n[1] 15  4\n\nsum(A)\n\n[1] 1830\n\nmean(A)\n\n[1] 30.5\n\nvar(A)\n\n     [,1] [,2] [,3] [,4]\n[1,]  320  320  320  320\n[2,]  320  320  320  320\n[3,]  320  320  320  320\n[4,]  320  320  320  320\n\nsummary(A)\n\n       V1           V2           V3           V4    \n Min.   : 1   Min.   : 2   Min.   : 3   Min.   : 4  \n 1st Qu.:15   1st Qu.:16   1st Qu.:17   1st Qu.:18  \n Median :29   Median :30   Median :31   Median :32  \n Mean   :29   Mean   :30   Mean   :31   Mean   :32  \n 3rd Qu.:43   3rd Qu.:44   3rd Qu.:45   3rd Qu.:46  \n Max.   :57   Max.   :58   Max.   :59   Max.   :60  \n\n\n\n\n2.2.3 행렬의 연산\n\nelement-wise operation은 행렬에서도 유효하다.\n\n\na = matrix(1:4, nrow = 2, byrow = T) \nb = a\nexp(a)\n\n          [,1]      [,2]\n[1,]  2.718282  7.389056\n[2,] 20.085537 54.598150\n\na + b \n\n     [,1] [,2]\n[1,]    2    4\n[2,]    6    8\n\n2 * a\n\n     [,1] [,2]\n[1,]    2    4\n[2,]    6    8\n\na * b\n\n     [,1] [,2]\n[1,]    1    4\n[2,]    9   16\n\na^2\n\n     [,1] [,2]\n[1,]    1    4\n[2,]    9   16\n\n\n\n행렬의 곱셈은 연산자 %*%을 사용한다.\n\n\na = matrix(1:4, nrow = 2, byrow = T) \nb = a\nx = c(1, 1)\na %*% b\n\n     [,1] [,2]\n[1,]    7   10\n[2,]   15   22\n\na %*% x\n\n     [,1]\n[1,]    3\n[2,]    7\n\ny = matrix(c(1,2), nrow = 1)\n\n## a와 y의 행렬곱도 해 보라. 계산이 잘 정의되지 않는다. 왜?\ndim(y)\n\n[1] 1 2\n\nz = a[1, ] \na %*% z\n\n     [,1]\n[1,]    5\n[2,]   11\n\ndim(z)\n\nNULL\n\n\n\n위 계산에서 x는 길이 2짜리 벡터이므로 자동으로 열벡터로 취급되어 a %*% x가 잘 정의된다. y는 1 by 2 matrix이므로 a %*% y가 잘 정의되지 않는다. y가 1 by 2 matrix임은 dim(y)를 통해 확인할 수 있다. z는 명령어로 보건대 1 by 2 matrix같은데 a %*% z는 또 잘 계산된다. dim(z)가 NULL값을 반환하는 것으로 보아 z는 벡터임을 알 수 있다. 어떤 알고리즘 때문인지, 저렇게 추출한 z는 벡터 상태가 되었다.\nR은 고급 행렬 연산도 모두 지원한다.\n\n\na = matrix(1:4, nrow = 2, byrow = T) \nt(a)                    # transpose of a\n\n     [,1] [,2]\n[1,]    1    3\n[2,]    2    4\n\nsolve(a)                # inverse of a\n\n     [,1] [,2]\n[1,] -2.0  1.0\n[2,]  1.5 -0.5\n\ndet(a)              # determinant of a\n\n[1] -2\n\ndiag(a)                 # diagonal elements of a, if a is a matrix\n\n[1] 1 4\n\nsvd(a)              # SVD of a\n\n$d\n[1] 5.4649857 0.3659662\n\n$u\n           [,1]       [,2]\n[1,] -0.4045536 -0.9145143\n[2,] -0.9145143  0.4045536\n\n$v\n           [,1]       [,2]\n[1,] -0.5760484  0.8174156\n[2,] -0.8174156 -0.5760484\n\nqr(a)                   # QR decomposition of a\n\n$qr\n           [,1]       [,2]\n[1,] -3.1622777 -4.4271887\n[2,]  0.9486833 -0.6324555\n\n$rank\n[1] 2\n\n$qraux\n[1] 1.3162278 0.6324555\n\n$pivot\n[1] 1 2\n\nattr(,\"class\")\n[1] \"qr\"\n\n\n\n\n2.2.4 행/열 단위의 함수 적용\n\n예제용으로 4 by 4 행렬 X를 만들자.\n\n\nX = matrix(1:16, 4, 4) \n\n\n행별/열별 평균이나 합은 rowMeans(), colMeans(), rowSums(), colSums()를 사용할 수 있다. 일반적으로 R에서는 행렬에서 행/열 단위로 임의의 함수를 적용한 결과를 한꺼번에 얻을 수 있는 함수 apply()가 있다. apply의 사용법은 apply(행렬, 행/열방향, 적용할 함수).\n\n\napply(X, 1, mean)       # 1 : rowwise\n\n[1]  7  8  9 10\n\napply(X, 2, mean)       # 2 : columnwise\n\n[1]  2.5  6.5 10.5 14.5\n\n\n\napply(X, 1, mean)은 rowMeans()와 같은 효과를 내고 있다.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>R - 행렬과 벡터</span>"
    ]
  },
  {
    "objectID": "R-3-statements.html",
    "href": "R-3-statements.html",
    "title": "3  R - 조건문, 반복문, 함수를 이용한 프로그래밍",
    "section": "",
    "text": "3.1 조건문(if/else)",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>R - 조건문, 반복문, 함수를 이용한 프로그래밍</span>"
    ]
  },
  {
    "objectID": "R-3-statements.html#조건문ifelse",
    "href": "R-3-statements.html#조건문ifelse",
    "title": "3  R - 조건문, 반복문, 함수를 이용한 프로그래밍",
    "section": "",
    "text": "if/else문의 기본 문법은 다음과 같다.\n\nif ( condition )\n{\n    expression\n    ....\n}\n\nif ( condition )\n{\n    expression 1\n    ....\n} else      # }과 else 사이에 엔터키가 있        # 으면 안됨\n{\n    expression 2\n    ....\n}\n\n만약 condition이 참이면 expression을 실행하라. (거짓이면 실행하지 않음)\n만약 condition이 참이면 expression 1을 실행하고, 그렇지 않으면 expression 2를 실행하라.\ncondition에는 참/거짓을 판별할 수 있는 문장을 적는다.\n\ne.g.) a == 3, 4 &gt; b, a &gt;= b, a &lt; b, a &lt; 0, …\n\nexpression에는 실행하고 싶은 명령어들을 자유롭게 입력한다. 아무거나 해도 된다. 몇 줄이 되어도 상관 없다. 새 변수를 정의해서 더하고 빼고 벡터를 새로 만들어서 그걸 또… 등등. if구문 안에 또 if를 집어넣는 것 또한 당연히 된다.\n조건에 쓰이는 괄호와 실행문에 쓰이는 중괄호는 (일단은) 반드시 필요하다(고 하자).\n( condition )과 중괄호 { 사이에 절대로 세미콜론을 쓰면 안 된다.\n\n\n3.1.1 예제 1. 두 수의 일치/불일치 여부 판별\n\na = 3\nb = 3 \n\nif ( a == b )\n{\n    c = 1           \n} else\n{\n    c = 0\n}\n\nc \n\n[1] 1\n\n\n\na와 b의 값을 바꾸어 가며 c의 값이 어떻게 달라지는지 실험해 보라.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>R - 조건문, 반복문, 함수를 이용한 프로그래밍</span>"
    ]
  },
  {
    "objectID": "R-3-statements.html#반복문for",
    "href": "R-3-statements.html#반복문for",
    "title": "3  R - 조건문, 반복문, 함수를 이용한 프로그래밍",
    "section": "3.2 반복문(for)",
    "text": "3.2 반복문(for)\n\n다음 예제를 이용하여 설명한다.\n\n\n3.2.1 예제 2. 성분 10개짜리 벡터에 차례대로 홀수 저장하기&gt;\n\n물론 다음 코드는 rep(1, 19, 2) 를 입력한 결과와 완벽하게 똑같지만, for를 익히기 위해 잊자.\n\n\na = rep(0, 10)              # 변수 초기화\n\nfor (i in 1:10)\n{\n    a[i] = 2*i - 1          # a[i] : 벡터 a의 i번째 성분값\n}\n\na \n\n [1]  1  3  5  7  9 11 13 15 17 19\n\n\n\ni에 1, 2, 3, … , 10이 차례대로 대입되면서 중괄호 안의 명령을 반복적으로 수행한다.\n꼭 대입될 변수의 이름이 i일 필요는 없다. 아무 변수나, 이름짓는 규칙만 만족한다면 OK. 보통 수학에서의 관습을 따라 i, j, k, … 등을 흔히 쓴다.\n1:10은 아까 벡터 소개 부분에서도 언급했듯 1부터 10까지 차례대로 나열된 벡터 c(1, 2, …, 10)를 뜻한다. 그 말은, 위의 for 구문을 입력할 때 (i in 2:19), (i in c(5, 1, 3)), … 같은 형태가 모두 가능하다는 뜻이다.\nif구문의 {} 내부와 마찬가지로, for 구문의 {} 내부에도 아무거나 자유롭게 입력할 수 있다.\n문법을 정리하면 다음과 같다.\n\nfor ( 변수 in 변수가 차례대로 취할 수들을 나열한 벡터 )\n{\n    expression\n}\n\n중괄호 안에 반드시 i(반복하여 대입되는 문자)가 쓰여야 하는 건 아니다. 예를 들면,\n\n\n\n3.2.2 예제 3. for 구문을 이용하여 (2k + 1) 수열의 10번째 항 구하기\n\na = 1               # 변수 초기화. 지금은 수열의 0번째 항 저장\n\nfor (i in 1:10)\n{\n    a = a + 2\n}\n\na\n\n[1] 21\n\n\n\nfor 구문을 잘 들여다 보면, 한 번 반복 수를 정하면(위에서는 i=1부터 i=10까지 10번) 그 횟수만큼은 꼭 루프를 돌아야 할 것 같다. 때에 따라서는 “평상시에는 정상적인 반복문을 수행하되 만약 어떤 일이 생기면 반복을 그만 두어라” 라고 명령하고 싶어질 수도 있다. 그럴 때는 break를 이용한다.\n\n\n\n3.2.3 예제 4. (2^k - 1) 수열에서 10^10보다 작은 마지막 항과 그 항의 값 알아내기\n\nmaxiter = 10000\n\nfor (i in 1:maxiter)\n{\n    a = 2^i - 1 \n    if (a &gt; 10^10)\n    {\n        res.index = i - 1 \n        res.value = 2^(res.index) - 1 \n        break \n    }\n}\n\nres.index \n\n[1] 33\n\nres.value \n\n[1] 8589934591",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>R - 조건문, 반복문, 함수를 이용한 프로그래밍</span>"
    ]
  },
  {
    "objectID": "R-3-statements.html#함수function",
    "href": "R-3-statements.html#함수function",
    "title": "3  R - 조건문, 반복문, 함수를 이용한 프로그래밍",
    "section": "3.3 함수(function)",
    "text": "3.3 함수(function)\n\n자주 쓰이는 알고리즘을 코드에서 반복적으로 입력하는 것보다는, 함수의 형태로 짜 놓았다가 호출하는 것이 더 효율적이다. 가령, (3 + 3 - 1)^2, (-6 + 10 - 1)^2, … 등의 값이 자꾸 필요한 상황이라면, 이것들을 일일이 입력하는 것보다는 F(x1, x2) = (x1 + x2 - 1)^2 라고 R에게 알려주고 F(3, 3), F(-6, 10)… 등을 이용하는 것이 편하다.\n다음을 입력하고 실행해 보라.\n\n\nF = function(x1, x2)\n{\n    temp = x1 + x2 - 1 ;\n    return ( temp^2 ) ;\n}\n\n\n아마 R은 아무런 반응을 하지 않았을 것이다. 그러나 R은 이제 F의 규칙을 기억하였다. 다음을 시도하여 보라.\n\n\nF(3, 1)\n\n[1] 9\n\nresult = F(3, 1)\nresult\n\n[1] 9\n\na = 3 ; b = 1 ; result = F(a, b) \nresult\n\n[1] 9\n\n\n\n함수 내부에서 계산된 temp에 대해 temp^2값이 최종적으로 반환(return)됨을 알 수 있다.\n문법을 정리하면 다음과 같다.\n\n함수 이름 = function(input variables)   # input variable는 여러 개여도 되고, 아예 없어도 된다.\n{\n    expression\n    return(value)           # return시키고 싶은 값이 없으면 안 써도 됨\n}\n\nfor나 if에서처럼 중괄호 안의 expression 안에서는 여러 명령을 중첩하여 입력할 수 있다.\n\n\n3.3.1 예제 5. 벡터 x의 성분 중 홀수의 개수를 세는 함수\n\noddcount = function(x)\n{\n    count = 0 ;\n    n = length(x) ;         # length(벡터) : 벡터의 길이를 리턴하는 함수\n    for (i in 1:n)\n    {\n        temp = x[i] %% 2 ;  # a %% b : a를 b로 나눈 나머지(remainder)\n        if (temp == 1) { k = k + 1 ;}\n    }\n    return(k) ;\n}\n\n\noddcount(c(1,5,2)) ;…. 등을 자유롭게 입력하여 보라.\n위 함수 안에는 count, n, temp 등 다양한 변수가 쓰였다. 그러면 함수 바깥에서 저 변수들이 여전히 자기 값을 갖고 있을까? 다음을 입력해 보라. 아마 변수를 못 찾겠다는 메시지가 뜰 것이다.\n\n\ncount\nn\ntemp\n\n\n함수 안에서 정의된 변수(위 예제에서는 count, n, i, temp, k)는 지역 변수이다. 즉, 함수 내부 계산을 마치고 밖으로 빠져나오면 사라진다. 바깥에서 같은 이름의 변수를 써도, 함수 바깥에 있는 변수는 변하지 않는다.\n\n\nrm(list=ls())       # 작업공간(메모리) 상의 모든 개체 삭제\nmyftn = function(a, b=2) {temp = 4 ; return( a + b + temp ) }\ntemp ;          # 함수 내에서 사용된 temp는 함수가 끝나고 사라진다.\n에러:개체 'temp'이 없습니다\ntemp = 0\nmyftn(0)\n[1] 6\ntemp            # 함수 내에서 사용된 temp는 함수 바깥의 temp와는 아예 다른              # 세상(?)에서 살다가 사라진다.\n[1]\n\n\n함수를 만들 때는 input variable들을 무엇으로 할 것인가, 무엇을 return할 것인가(하지 않을 것인가)를 생각하고 만드는 것이 좋다.\n함수를 만들 때 등호로써 기본값을 미리 지정할 수 있다. MAXITER나 initial value같은 귀찮은 input을 다룰 때 유용하다.\n\n\nmyftn = function(a, b=2) return( a + b ) \nmyftn(a=4) \n\n[1] 6\n\nmyftn(a=4, b=3) \n\n[1] 7",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>R - 조건문, 반복문, 함수를 이용한 프로그래밍</span>"
    ]
  },
  {
    "objectID": "R-3-statements.html#예제들",
    "href": "R-3-statements.html#예제들",
    "title": "3  R - 조건문, 반복문, 함수를 이용한 프로그래밍",
    "section": "3.4 예제들",
    "text": "3.4 예제들\n\n3.4.1 예제 6\n벡터의 평균을 계산하는 함수 mymean()을 만들되 다음 규칙을 따라서 만들라.\n\ninput : 벡터 x, output : 평균값\nmean()이나 sum()함수를 쓰지 말 것\nfor 문을 이용하여 벡터 x의 성분들에 직접 접근할 것\n함수를 테스트할 수 있는 코드도 같이 작성할 것\n\n\nmymean = function(x)\n{\n    n = length(x)           # n에 x의 길이 입력\n    sum.temp = 0 ;          # sum.temp : 벡터의 성분별 누적합을 저장할 공간\n    for (i in 1:n) sum.temp = sum.temp + x[i] ;\n         # 한 루프마다 실행할 명령이 하나뿐이므로 굳이 중괄호 {}를 입력하지 않음\n    return(sum.temp / n) ;      # (벡터 성분 총합) / 벡터 길이를 리턴\n}\n\na = c(1, 2, 3, 4)\nb = c(0, 1, 0, 1)\nmymean(a)\n\n[1] 2.5\n\nmymean(b)\n\n[1] 0.5\n\n\n\n\n3.4.2 예제 7\n\\(a_{n+1} = f(a_n)\\)으로 정의된 수열 \\(\\{a_n\\}\\)의 수렴 여부를 판정하는 함수 convtest()를 다음 규칙에 따라 만들라. - input : 함수 F, 수열의 초항(\\(a_0\\)) a, \\(n\\)에 대입할 최대 index M - for문 이용 - for문의 매 루프마다 loop index와 \\(|a_n - a_{n-1}|\\)을 화면에 출력할 것 - n = M까지 가기 전에 \\(|a_n - a_{n-1}| &lt; 10^{-6}\\)이 달성되면 수렴된 것으로 판정하고 그 때의 \\(a_n\\)값을 수렴값으로서 반환, 만약 n = M이 되어도 \\(|a_n - a_{n-1}| &lt; 10^{-6}\\)이 달성되지 않으면 수렴하지 않은 것으로 판정하고 NULL을 반환 - \\(f(t) = \\sqrt{t+1}\\), a = 1, M = 100 으로 테스트 코드 작성\n\nconvtest = function(F, a, M)\n{\n    a.new = a               # a.new의 초기화\n    for (i in 1:M)\n    {\n        a.old = a.new \n        a.new = F(a.old) \n        err = abs(a.new - a.old)    # err에  대입\n        cat(\"Step \", i, \", current error : \", err, \"\\n\", sep=\"\") \n        if ( err &lt; 10^(-6) )\n        {\n            cat(\"Convergence occured!!\\n\") \n            return(a.new) \n        }\n    }\n    cat(\"Convergence not occured\\n\") \n    return(NULL) \n}\n\nf = function(t) return( sqrt(t + 1) ) ; a = 1 ; M = 100 \nconvtest(f, a, M) \n\nStep 1, current error : 0.4142136\nStep 2, current error : 0.1395604\nStep 3, current error : 0.04427921\nStep 4, current error : 0.01379457\nStep 5, current error : 0.004273452\nStep 6, current error : 0.001321592\nStep 7, current error : 0.0004084921\nStep 8, current error : 0.0001262403\nStep 9, current error : 3.90113e-05\nStep 10, current error : 1.205524e-05\nStep 11, current error : 3.725282e-06\nStep 12, current error : 1.151176e-06\nStep 13, current error : 3.557331e-07\nConvergence occured!!\n\n\n[1] 1.618034",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>R - 조건문, 반복문, 함수를 이용한 프로그래밍</span>"
    ]
  },
  {
    "objectID": "R-4-list-dfs-io.html",
    "href": "R-4-list-dfs-io.html",
    "title": "4  R - 데이터(테이블) 다루기",
    "section": "",
    "text": "4.1 개요",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>R - 데이터(테이블) 다루기</span>"
    ]
  },
  {
    "objectID": "R-4-list-dfs-io.html#개요",
    "href": "R-4-list-dfs-io.html#개요",
    "title": "4  R - 데이터(테이블) 다루기",
    "section": "",
    "text": "데이터 프레임 (data.frame) : 길이가 동일한 수치/문자열/논리 벡터들을 열별로 합쳐놓은 자료형. 지난 세션까지는 벡터 자료형과 행렬 자료형만 주로 다루었다. 벡터와 행렬 모두 한 객체에 동일한 유형 (수치형이면 수치형, 문자열이면 문자열)만 저장할 수 있다. 그러나 보통의 테이블 자료(tabular data)는 열(필드)마다 수치/문자열/논리 유형이 다른 복합 테이블이므로, R의 행렬 자료형은 테이블 자료를 담기에 적절하지 않고, 데이터 프레임으로 담아낼 수 있다.\n리스트 (list) : 리스트는 여러 객체들의 단순 모음이다. 서로 다른 길이의 벡터, 행렬, 문자열, 혹은 다른 리스트도 모아놓을 수 있다.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>R - 데이터(테이블) 다루기</span>"
    ]
  },
  {
    "objectID": "R-4-list-dfs-io.html#리스트",
    "href": "R-4-list-dfs-io.html#리스트",
    "title": "4  R - 데이터(테이블) 다루기",
    "section": "4.2 리스트",
    "text": "4.2 리스트\n\n4.2.1 리스트의 생성 및 접근\n\n리스트는 생성법은 아래와 같다.\n\n\na = c(\"David\", \"Brownie\")\nb = 100\nc = matrix(1:4, nrow = 2)\nmylist = list(u = a, v = b, w = c)\nmylist\n\n$u\n[1] \"David\"   \"Brownie\"\n\n$v\n[1] 100\n\n$w\n     [,1] [,2]\n[1,]    1    3\n[2,]    2    4\n\n\n\n리스트의 각 구성요소는 $ 기호를 이용하여 접근할 수 있다. 혹은 double bracket [[]]으로 접근이 가능하다.\n\n\nmylist = list( u = c(\"David\", \"Brownie\"), v = 100, w = matrix(1:4, nrow = 2) )\nmylist$u\n\n[1] \"David\"   \"Brownie\"\n\nmylist$w\n\n     [,1] [,2]\n[1,]    1    3\n[2,]    2    4\n\nmylist[[1]]\n\n[1] \"David\"   \"Brownie\"\n\nmylist[[2]]\n\n[1] 100\n\nmylist[[3]]\n\n     [,1] [,2]\n[1,]    1    3\n[2,]    2    4\n\nmylist$w[2, 1]\n\n[1] 2\n\n\n\n\n4.2.2 리스트의 활용\n\n주로 함수를 만들 때 여러 종류의 변수를 한꺼번에 반환하고 싶은 경우 리스트를 활용한다. 예를 들면 아까 qr() 함수도 한꺼번에 여러 변수를 리스트로 리턴하였다. 따라서 qr() 함수의 결과에 접근하려면 $을 이용해야 한다.\n\n\nmat = matrix(1:4, nrow = 2, byrow = T)\nqr(mat)\n\n$qr\n           [,1]       [,2]\n[1,] -3.1622777 -4.4271887\n[2,]  0.9486833 -0.6324555\n\n$rank\n[1] 2\n\n$qraux\n[1] 1.3162278 0.6324555\n\n$pivot\n[1] 1 2\n\nattr(,\"class\")\n[1] \"qr\"\n\nqr(mat)$qr\n\n           [,1]       [,2]\n[1,] -3.1622777 -4.4271887\n[2,]  0.9486833 -0.6324555\n\nQ = qr(mat)\nQ$qr\n\n           [,1]       [,2]\n[1,] -3.1622777 -4.4271887\n[2,]  0.9486833 -0.6324555",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>R - 데이터(테이블) 다루기</span>"
    ]
  },
  {
    "objectID": "R-4-list-dfs-io.html#데이터-프레임",
    "href": "R-4-list-dfs-io.html#데이터-프레임",
    "title": "4  R - 데이터(테이블) 다루기",
    "section": "4.3 데이터 프레임",
    "text": "4.3 데이터 프레임\n\n4.3.1 데이터 프레임의 생성 및 접근\n\n데이터 프레임도 2차원 사각형의 성분에 자료를 저장한 것이다. 언뜻 보면 행렬과 비슷해 보인다. 가장 큰 차이는, 행렬은 모든 성분의 변수형이 동일(문자형만 저장 혹은 실수형만 저장)해야 하나 데이터 프레임은 여러 변수형의 자료를 한 곳에 저장할 수 있다는 것이다. 뿐만 아니라 데이터 프레임은 변수명, 관측치 번호 등 여러 정보를 동시에 저장해준다.\n\n\nname = c(\"David\", \"Brownie\", \"John\")\nage = c(20, 10, 23)\nscore = c(10, 9, 10)\nmydata = data.frame(name, age, score)\nmydata\n\n     name age score\n1   David  20    10\n2 Brownie  10     9\n3    John  23    10\n\n\n\n데이터 프레임 형식의 자료는 행렬처럼 접근할 수도, 리스트처럼 접근할 수도 있다.\n\n\nmydata = data.frame(name = c(\"David\", \"Brownie\", \"John\"),\n            age = c(20, 10, 23), score = c(10, 9, 10))\nmydata[ ,1]\n\n[1] \"David\"   \"Brownie\" \"John\"   \n\nmydata[1, ]\n\n   name age score\n1 David  20    10\n\nmydata$name\n\n[1] \"David\"   \"Brownie\" \"John\"",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>R - 데이터(테이블) 다루기</span>"
    ]
  },
  {
    "objectID": "R-4-list-dfs-io.html#파일-입출력",
    "href": "R-4-list-dfs-io.html#파일-입출력",
    "title": "4  R - 데이터(테이블) 다루기",
    "section": "4.4 파일 입출력",
    "text": "4.4 파일 입출력\n\n원자료(raw data)를 다른 파일에서 읽어들이고, 혹은 가공한 자료를 외부 파일로 내보내는 기능이 필요할 때가 많다. 지금은 txt(텍스트) 형식으로 행렬 / 데이터 프레임을 입출력하는 방법에 대해 알아보자.\n\n\n4.4.1 파일 출력\n\n위의 mydata를 텍스트 파일로 출력하고 싶다면? write.table() 함수를 이용한다. 아래의 코드에서, 저장할 파일의 주소를 입력할 때 백슬래시()가 아닌 슬래시(/)를 쓴다는 점에 주의하자. 코드를 실행한 후에 저장이 잘 됐는지 확인해 보라.\n\n\ngetwd()\n\n[1] \"/Users/cyg/Dropbox/Documents/Teaching/2024g-longitudinal/lecNote_longitudinal\"\n\nmydata = data.frame(name = c(\"David\", \"Brownie\", \"John\"),\n            age = c(20, 10, 23), score = c(10, 9, 10))\nwrite.csv(mydata, '/Users/cyg/Dropbox/Documents/Teaching/2024g-longitudinal/lecNote_longitudinal/CS_mydata.csv')\n\n\n위에서 저장한 텍스트 파일을 열어보면 다음과 같이 자료가 공백으로 구분되어 저장되어 있다. 열 이름과 행 이름도 포함되었다.\n\n\"name\" \"age\" \"score\"\n\"1\" \"David\" 20 10\n\"2\" \"Brownie\" 10 9\n\"3\" \"John\" 23 10\n\n만약 열 이름은 저장하되 행 이름을 저장하고 싶지 않다면?\n\nwrite.table(mydata, '(경로)/CS_mydata_nonames.txt', row.names=FALSE, col.names=TRUE) \n\n위와 같이 저장하고 텍스트 파일을 열어 보면,\n\n\"David\" 20 10\n\"Brownie\" 10 9\n\"John\" 23 10\n\n\n4.4.2 파일 입력\n\nCS_mydata.txt에는 첫째줄에 각 열의 이름이 적혀 있다. 이런 파일을 읽어들이려면?\n\nX = read.csv(\"(경로)/CS_mydata.csv\", header=TRUE)\nX \n     name age score\n1   David  20    10\n2 Brownie  10     9\n3    John  23    10\n\n파일에 열/행의 이름(header)가 존재하냐 여부에 따라 read.table의 header 옵션을 조정해 주면 된다. 사실 R은 나름 똑똑하기 때문에 웬만한 자료는 굳이 header 옵션을 넣지 않아도 상황에 맞게 인식하긴 하나, 만약을 위해 알아두자.\n\n\n\n4.4.3 예제 1.\n다음과 같은 데이터 프레임 scoretable이 있다.\n&gt; scoretable\n     name math english physics\n1   Stark   52      45      72\n2   Stacy   22      84      73\n3    John   59      31      90\n4 Brownie   84      29      75\n5     Sam   71      73      30\n6  Sherry   56      19      82\n\n\n위 데이터 프레임에 학생별 평균 column과 총점 column을 추가하여 새로운 데이터 프레임 scoretable.new를 얻고 이를 e:\\CS\\scoretablenew.csv로 저장코자 한다. 이를 위한 코드를 작성하여라.\n\n\n(1)에서 만든 데이터 프레임 scoretable.new, 과목별 평균점수의 벡터 subject.mean, 과목별 총점의 벡터 subject.sum을 구성요소로 하는 리스트 scoretable.list를 작성하고자 한다. 이를 위한 코드를 작성하여라.\n\n(Hint : for 함수를 이용해서 열별/행별로 평균 및 합을 계산하는 것이 가장 기본적이나, 이제부터는 함수 rowSums(), rowMeans(), colSums(), colMeans()를 이용하자. 네 함수 모두 input 인자는 행렬이다. 행렬 하나를 만든 다음에 위 함수들을 테스트해 보면 금방 그 뜻과 사용법을 알 것이다.)\n\n\n\n\nstu.mean = rowMeans( scoretable[ ,-1] ) # 1열에는 문자형 자료가 있으므로 1열 제거\nstu.sum = rowSums( scoretable[ ,-1] )\n\nscoretable.new = data.frame(scoretable, mean = stu.mean, sum = stu.sum)\nwrite.csv(scoretable.new, \"(경로)/scoretablenew.csv\", row.names=FALSE, col.names=TRUE)\n\n\n\n\n\n\nsubject.mean = colMeans( scoretable[ ,-1] )\nsubject.sum = colSums( scoretable[ ,-1] )\n\nscoretable.list = list(scoretable.new, subject.mean, subject.sum)",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>R - 데이터(테이블) 다루기</span>"
    ]
  },
  {
    "objectID": "R-4-list-dfs-io.html#필터링",
    "href": "R-4-list-dfs-io.html#필터링",
    "title": "4  R - 데이터(테이블) 다루기",
    "section": "4.5 필터링",
    "text": "4.5 필터링\n\n통계 분석에서는 관심사에 따라 특정 조건을 만족하는 데이터만 보는 일이 잦을 것이다. 가령 인구 자료가 있다면 특정 지역에 사는 사람이나 특정 키 이상의 사람들만 따로 보고 싶을 수도 있다. 이런 문제들을 잘 생각해보면, x = c(7, 2, 30, 6, 9)에 대해 다음과 같은 과제들을 해결하는 것과 본질적으로 (거의) 같다.\n\nx에서 8보다 큰 성분의 index 검색\n\n\nx에서 8보다 큰 성분만 골라 0으로 변경\n\n\nx의 성분들을 오름차순/내림차순으로 정렬\n\n\n물론 for (i in 1:5)… 로 시작하는 구문을 이용하여 인덱스 하나하나에 대해 8보다 큰지 if문을 통해 물어보고 맞으면 그 index를 …… 하는 방법으로 위의 문제에 대처할 수는 있다. R에서는, 머리를 좀 굴린다는 전제 하에 매우 간단하게 할 수 있다.\n\n벡터 a에 대하여 a[index]로 특정 성분 및 특정 성분 몇 개를 동시에 불러올 수 있음을 세션 1에 학습하였다. 좀 더 보충할 것이 있다. 먼저, 호출할 index는 중복 및 순서변경이 가능함을 기억하자. 추후에 사용될 때가 있다.\n\n\nx = c(7, 2, 30, 6, 9)\nx[ c(4, 3, 3, 5, 1, 1) ]\n\n[1]  6 30 30  9  7  7\n\n\n\n논리형 벡터를 이용하여 특정 성분만을 불러올 수도 있다. 이 때 논리형 벡터의 길이는 접근 대상 벡터의 길이와 같아야 한다. 만약 길이가 다르면 의도치 않은 값들도 출력된다.\n\n\nx = c(7, 2, 30, 6, 9)\nx[ c(T, F, T, T, F) ] \n\n[1]  7 30  6\n\n    # x[ c(TRUE, FALSE, TRUE, TRUE, FALSE) ] 라 쓰는 것과 똑같다.\nx[ c(T, F, T, T, F, T, F) ]\n\n[1]  7 30  6 NA\n\n\n\nR은 논리문(참거짓을 판단할 수 있는 문장)에 대해 TRUE/FALSE를 판정하는 기능이 있음을 학습하였다. R은 벡터와 친하다는 것도 기억하는가? R은 벡터 통째로도 T/F를 판정해줄 수 있다.\n\n\na = 4 ; x = c(7, 2, 30, 6, 9)\na &gt; 8\n\n[1] FALSE\n\nx &gt; 8\n\n[1] FALSE FALSE  TRUE FALSE  TRUE\n\n\n\n이쯤하면 아까 제기된 문제 ①, ②에 답할 준비가 끝났다. 먼저 ①부터. which() 함수는 논리형 벡터에 대해 TRUE인 index만을 출력해 주는 함수이다. 이것을 이용하면 ①은 해결.\n\n\nwhich( c(F, F, T, F, T) )\n\n[1] 3 5\n\nwhich( x &gt; 8 )\n\n[1] 3 5\n\n\n\n두 명령어가 왜 같은 답을 주는가?\n②를 해결하여 보자. 아래 명령어들이 사실 모두 같은 말을 하고 있다는 것이 포인트. 반복적인 실험을 위해 원본 x로부터 사본 y를 복사해서 쓰자.\n\n\nx = c(7, 2, 30, 6, 9)\ny = x\ny[ c(3, 5) ] = 0\ny\n\n[1] 7 2 0 6 0\n\ny = x\ny[ which(y &gt; 8) ] = 0\ny\n\n[1] 7 2 0 6 0\n\ny = x\ny[ c(F, F, T, F, T) ] = 0\ny\n\n[1] 7 2 0 6 0\n\ny = x\ny[ y &gt; 8 ] = 0\ny\n\n[1] 7 2 0 6 0\n\n\n\n논리 연산자에는 ‘!’(not), ‘|’(or), ‘&’(and)도 있다. 이를 활용하면, 이를테면 ‘8보다 크고 15보다 작다’ 같은 조건도 쓸 수 있다. 다음은 필터링의 기본적인 변주법이다.\n\n\na = c(10, 15, 1, 5, 12) ; x = c(7, 2, 30, 6, 9)\nb = a ; y = x\n\n\ny에서 제곱이 40보다 작은 성분들의 index는? 혹은 그러한 성분들을 0으로 만들기\n\n\nwhich( y^2 &lt; 40 )\n\n[1] 2 4\n\ny[ y^2 &lt; 40 ] = 0\ny\n\n[1]  7  0 30  0  9\n\n\n\nb에서 10보다 작거나 같은 성분들의 번호에 대응하는 y의 성분들을 0으로 만들기\n\n\ny = x\ny[ b &lt;= 10 ] = 0\ny\n\n[1] 0 2 0 0 9\n\n\n\nb에서 5와 15 사이에 있는 성분들의 index는?\n\n\nwhich( (b &gt;= 5) & (b &lt;= 15) )\n\n[1] 1 2 4 5\n\n\n\n③을 해결하려면 order() 함수가 필요하다. order(x)는 x 벡터에서 성분이 가장 작은 index부터 차례대로 나열해주는 함수이다. rank(x)와는 조금 다르다.\n\n\nx = c(7, 2, 30, 6, 9)\norder(x)\n\n[1] 2 4 1 5 3\n\nrank(x)\n\n[1] 3 1 5 2 4\n\nx[ c(2, 4, 1, 5, 3) ]\n\n[1]  2  6  7  9 30\n\nx[ order(x) ]\n\n[1]  2  6  7  9 30\n\n\n\n내림차순으로 정렬하려면? order 명령어에서 order(x, decreasing=TRUE) 라고 새로 옵션을 추가하면 된다.\n\n\nx = c(7, 2, 30, 6, 9)\norder(x, decreasing=TRUE)\n\n[1] 3 5 1 4 2\n\nx[order(x, decreasing=TRUE)]\n\n[1] 30  9  7  6  2\n\n\n\n위의 논의들이 행렬 혹은 데이터 프레임에 적용되면 필터링 기술의 진가가 드디어 발휘된다. 코드를 입력할 때마다 결과를 예측해보고, 확인하고, 이유를 생각해 보자. 이 부분이 실제 데이터 분석에서 가장 많이 쓰인다. 결과 생략.\n\n\nname = c(\"A\", \"B\", \"C\", \"D\", \"E\")\nmath = c(69, 19, 74, 53, 90)\neng = c(28, 85, 74, 57, 91)\ndata = data.frame(name, math, eng)\n\n# 수학이 50점 이상인 사람만 출력\ndata[ (data$math &gt;= 50) , ]\n\n  name math eng\n1    A   69  28\n3    C   74  74\n4    D   53  57\n5    E   90  91\n\n# 이름순 나열\ndata[ order(data$name), ]\n\n  name math eng\n1    A   69  28\n2    B   19  85\n3    C   74  74\n4    D   53  57\n5    E   90  91\n\n# 총점을 계산하여 총점순으로 나열\ntotal = data$math + data$eng\ndata = data.frame(data, total)\norder.total = order(total, decreasing=TRUE)\ndata[ order.total , ]\n\n  name math eng total\n5    E   90  91   181\n3    C   74  74   148\n4    D   53  57   110\n2    B   19  85   104\n1    A   69  28    97\n\n\n\n행렬 혹은 데이터 프레임에서 특정 조건을 만족하는 성분에 특정 값을 대입할 수도 있다.\n\n\n# 수학이 50점 이하인 사람을 50점으로 고정\ndata$math[ (data[ ,2] &lt;= 50) ] = 50\n\n\nNA / NULL의 활용\n\n\nNA/NULL값은 실제 통계 분석에서 많이 사용된다. NA는 결측의 의미로 사용된다. NULL은 아무 것도 없는 상태를 나타내기 위해 쓰인다. 특히 특정 성분이 NA인지, NULL인지 검출하는 문장이 유용하다.\n\nRemark. NA나 NULL은 문자형 상수가 아니다. 예를 들면, a = “NA”라고 입력하는 것과 a = NA라고 입력하는 것은 전혀 다르다.\n\nname = c(\"A\", \"B\", \"C\", \"D\", \"E\")\nmath = c(69, NA, 74, 53, 90)\neng = c(28, 85, 74, 57, NA)\neng2 = c(28, 85, 74, 57, NULL)\ndata = data.frame(name, math, eng)\n# data2 = data.frame(name, math, eng2)  # 에러 발생\n\n\n수학이 결측인 학생 출력\n\n\nis.na(data$math)\n\n[1] FALSE  TRUE FALSE FALSE FALSE\n\ndata$math == NA      # c(NA, NA, NA, NA, NA) 출력될 것임 - 옳은 문법이 아님 \n\n[1] NA NA NA NA NA\n\ndata$name[ is.na(data$math) ]\n\n[1] \"B\"\n\n\n\n결측치에 0점 입력\n\n\ndata$math[ is.na(data$math) ] = 0\ndata$eng[ is.na(data$eng) ] = 0\n# data[ is.na(data) ] = 0 해도 됨",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>R - 데이터(테이블) 다루기</span>"
    ]
  },
  {
    "objectID": "R-4-list-dfs-io.html#r-요약",
    "href": "R-4-list-dfs-io.html#r-요약",
    "title": "4  R - 데이터(테이블) 다루기",
    "section": "4.6 R 요약",
    "text": "4.6 R 요약\n\n4.6.1 연산\n\nR은 벡터/행렬 단위의 연산이 가능, 길이가 다른 두 벡터의 연산에서는 만나면 짧은 벡터가 알아서 반복되며 긴 벡터와 길이를 강제로 맞춤\n기본적인 이항 연산자\n\n대입: =, &lt;-\n산술 계산: +, -, *, /, %%(mod), ^, %*%\n양변의 비교: ==, !=(not equal to), &gt;=, &gt;, &lt;=, &lt;\n논리문의 결합: &(and), |(or), !(not)\n\n기본적인 수치 연산 함수 (numeric 형 벡터/행렬에서만 가능)\n\n초등 초월함수: abs(), exp(), log(), log10(), sin(), cos(), tan(), asin(), acos(), atan()\n소수 자리의 처리: trunc(), round(), ceiling(), floor()\n행렬 연산: t(), tr(), rank(), solve(), qr(), svd()\n기타 (벡터-&gt;스칼라): sum(), mean(), max(), min()\n\n\n\n\n4.6.2 객체\n\n자료형별 객체생성법\n\n벡터: c(), rep(), seq(), (number):(number), as.vector(matrix)\n행렬: matrix(), diag(), cbind(), rbind()\n리스트: list()\n데이터 프레임: data.frame()\n\n개체 성분들의 유형 : character, logical, numeric, complex 등\n자료형별 객체 접근법\n\n벡터 x: x, x[4], x[c(2,5)], x[-c(2,3)], x[c(TRUE, FALSE, TRUE)]\n행렬 x: x[ , ], x[]. input argument는 벡터에서와 똑같이\n리스트 x: x, x$NAME1\n데이터 프레임 x: x$NAME1, x[ , ]\n\n외부 csv 파일로의 입출력 : read.csv(file, header=?), write.csv(data, file, row.names=?, col.names=?)\n\nread.table은 데이터 프레임의 형태로 데이터를 읽음, 연산을 원한다면 원자료에서 특정 행과 열을 데이터에서 취한 뒤에 as.matrix()나 as.vector()을 하여 연산이 가능한 형태로 바꾸어야 함 eg) data=read.table(…) ; X = as.matrix(data[,-1])\n\n\n\n\n4.6.3 함수\n\n생성 : 함수이름 = function(a, b, c….) {… ; … ; return(something) }\n호출 : 함수이름(a=xxx, b=xxx, c=xxx), 위에서 지정된 something이 반환됨\n기본값 지정 가능 eg) myftn = function(a, b=4) {..}\n함수 내부에서 사용되는 변수는 지역변수\n\n\n\n4.6.4 조건문 if\n\n사용법 : if (논리문) {….} else {….}\n논리문 자리에는 참/거짓을 판단할 수 있는 스칼라 형태의 문장을 사용 eg) 2==3 (O), c(1,2)==c(2,3) (X)\nelse를 쓰려면, else와 else 앞의 ‘}’ 사이에 세미콜론이나 엔터키가 없어야 함\n\n\n\n4.6.5 반복문 for\n\n사용법 : for (i in (vector)) {……}\ni가 (vector)의 값들을 순차적으로 취하면서 {} 안의 명령을 반복 수행\n(특정 조건 하에서) break으로 for문 탈출 가능\n\n\n\n4.6.6 행렬/벡터 단위의 정렬과 연산\n\n아래에 등장하는 코드들의 작동원리 및 결과를 반드시 이해하고 있어야 한다.\n\n\na = c(7, 2, 30, 6, 9) ; X = matrix(1:16, ncol=4)\nwhich(a &gt;= 2)\n\n[1] 1 2 3 4 5\n\na[ (a &gt;= 1) & (a &lt;= 4) ] = NA\nX[ (X %% 2) == 1 ] = 0\nX[ upper.tri(X) ] = 1000\nX[ row(X) &gt; col(X) ] = 5000\n\n\n정렬\n\n\nx = c(7, 2, 30, 6, 9)\norder(x) \n\n[1] 2 4 1 5 3\n\norder(x, decreasing=TRUE)\n\n[1] 3 5 1 4 2\n\nrank(x)\n\n[1] 3 1 5 2 4\n\nx[ order(x) ]\n\n[1]  2  6  7  9 30\n\n\n\n정렬과 필터링의 조합(★)\n\n\nname = c(\"DH\", \"YE\", \"SH\", \"YG\", \"JH\", \"YS\", \"HS\")\nmath = c(69, 19, 74, 53, 90, 14, 67)\neng = c(28, 85, 74, 57, 91, 27, 14)\ndata = data.frame(name, math, eng)\n\ndata[ (data[ ,2] &gt;= 50), ]  # 수학이 50점 이상인 사람만 출력\n\n  name math eng\n1   DH   69  28\n3   SH   74  74\n4   YG   53  57\n5   JH   90  91\n7   HS   67  14\n\ndata[ order(data[ ,1]), ]       # 이름순 나열\n\n  name math eng\n1   DH   69  28\n7   HS   67  14\n5   JH   90  91\n3   SH   74  74\n2   YE   19  85\n4   YG   53  57\n6   YS   14  27\n\n# 총점을 계산하여 총점순으로 나열\ntotal = as.vector(data[ ,2]) + as.vector(data[ ,3])\ndata = data.frame(data, total)\norder.total = order(total, decreasing=TRUE)\ndata[ order.total , ]\n\n  name math eng total\n5   JH   90  91   181\n3   SH   74  74   148\n4   YG   53  57   110\n2   YE   19  85   104\n1   DH   69  28    97\n7   HS   67  14    81\n6   YS   14  27    41\n\n\n\napply()의 활용 (★)\n\n\nmynorm = function(x) return( sum(x^2) )\nmaxmin = function(x) return( c(max(x), min(x)) )\nX = matrix(1:16, 4, 4)\napply(X, 1, mean)\n\n[1]  7  8  9 10\n\napply(X, 2, mynorm)\n\n[1]  30 174 446 846",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>R - 데이터(테이블) 다루기</span>"
    ]
  }
]